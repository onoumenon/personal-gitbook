# 1. Building Abstractions with Procedures

## 1.1 Elements of Programming

**All programming languages have:  
  
primitive expressions**  
represent the simplest entities the language is concerned with  
  
**means of combination**  
by which compound elements are built from simpler ones   
  
**means of abstraction**  
 by which compound elements can be named and manipulated as units.  
  
In programming we deal with: **procedures** and **data**  
\(Though they are not as distinct as you would think.\)  
  


### Basics of Lisp

| \(+  | 2.7  | 10\) |
| :---: | :---: | :---: |
| operator | operand | operand |

Lisp's convention of placing operator to the left is called **prefix notation**.

The interpreter always run in the same cycle: **read-eval-print loop.** An expression like `(+ ( 3 (+ ( 2 4) (+ 3 5))) (+ (- 10 7) 6))` which may be hard for humans to parse, easy for the interpreter to answer.



| \(define  | size  | 2\) |
| :---: | :---: | :---: |
|  | variable | value |

The interpreter must maintain some sort of memory that keeps track of the name-object pairs. This memory is called the **environment**. \(eg: global environment\). 



#### Compound Procedures

`(define (square x) (* x x))`

\(define \(⟨name⟩ ⟨formal parameters⟩\) ⟨body⟩\)

  
  
**General form of a conditional:** 

**`(define (abs x) (cond ((< x 0) (- x)) (else x)))`**  
  
****\(cond \(⟨p1⟩ ⟨e1⟩\) \(⟨p2⟩ ⟨e2⟩\) . . . \(⟨pn⟩ ⟨en⟩\)\)

Conditional expressions are evaluated as follows. Predicate ⟨p1⟩ is evaluated first. If its value is false, then ⟨p2⟩ is evaluated. If ⟨p2⟩’s value is also false, then ⟨p3⟩ is evaluated. The process continues until a predicate is found whose value is true, in which case the interpreter returns the value of the corresponding consequent expression ⟨e⟩ of the clause as the value of the conditional expression. If none of the ⟨p⟩’s is found to be true, the value of the cond is undefined.   
  
**Lisp is an applicative order language.**

#### \*\*\*\*

###  Applicative order versus normal order \(aka lazy evaluation\)

{% embed url="https://medium.com/background-thread/what-is-lazy-evaluation-programming-word-of-the-day-8a6f4410053f" %}

{% embed url="https://www.tutorialspoint.com/functional\_programming/functional\_programming\_lazy\_evaluation.htm" %}

Lazy evaluating is when a compiler only evaluates an expression when needed. This can be more efficient, for eg: short circuiting for &&. If the left side evaluates to false, then the right side is not evaluated. You can also work with infinite lists.



**Exercise 1.5**

What's the difference between trying to run the below code in an applicative order vs normal order compiler?

```text
(define (p) (p))
(define (test x y)
    (if (= x 0) 0 y))

(test 0 (p))
```

**Answer:**

In a strict evaluation/ applicative order compiler, the compiler is stuck at line one, which is a recursive function.   
  
In a lazy evaluation/ normal order compiler, since `p` is not needed yet, the compiler does not evaluate the first line. Since the parameter given satisfy the `(= x 0)` clause, '0' is returned as the result without even evaluating `y`.

### 

### Square Roots by Newton’s Method

Difference between mathematics functions and computer procedures: Procedures must be effective.

For eg, the mathematical function for finding the square root of a number can be defined as: **√ x = the y such that y ≥ 0 and y \*\* 2 = x**  
  
It is declarative rather than imperative. The imperative way of finding square root is through Newton’s method of successive approximations by averaging y with x/y.

For square root of 2:

![](../../.gitbook/assets/screenshot-2020-01-02-at-5.01.47-pm.png)

The pseudo-code:

```text
(define (sqrt-of guess x)
    (if (good-enough? guess x)
       guess
       (sqrt-of (improve guess x) x)))
    
```

It recursively improves the guesses until it is good enough, where good enough is defined as the difference between the squared guess and x being 0.001: 

```text
(define (good-enough? guess x)
(< (abs (- (square guess) x)) 0.001))
```

And the guess is improved each time using Newton's method:

```text
(define (improve guess x)
(average guess (/ x guess)))

(define (average x y)
(/ (+ x y) 2))
```

![I don&apos;t understand this yet](../../.gitbook/assets/screenshot-2020-01-02-at-6.10.53-pm.png)

{% embed url="http://community.schemewiki.org/?sicp-ex-1.6" %}



### Black Box Abstraction

By separating out a bigger procedure into smaller functions, these smaller functions can have their internal workings be hidden away.

#### Block Structure

To avoid cluttering the global namespace with `improve` and `good-enough`, contain them within a function that they are relevant in.

```text
(define (sqrt x)
    (define (good-enough? guess x)
        (< (abs (- (square guess) x)) 0.001))
    (define (improve guess x) (average guess (/ x guess)))
    (define (sqrt-iter guess x)
        (if (good-enough? guess x)
            guess
            (sqrt-iter (improve guess x) x)))
    (sqrt-iter 1.0 x))
```

Since there's no need to pass x around because of **lexical scoping**, the improved code looks like this:

```text
(define (sqrt x)
    (define (good-enough? guess)
        (< (abs (- (square guess) x)) 0.001))
    (define (improve guess)
        (average guess (/ x guess)))
    (define (sqrt-iter guess)
        (if (good-enough? guess)
            guess
            (sqrt-iter (improve guess))))
    (sqrt-iter 1.0))
```

## 1.2 Procedures and the Processes They Generate

Some common “shapes” for processes generated by simple procedures:

### Linear Recursion and Iteration

![](../../.gitbook/assets/screenshot-2020-01-03-at-12.27.29-pm.png)

```text
(define (factorial n)
    (if (= n 1)
        1
        (* n (factorial (- n 1)))))
```

![A linear recursive process for computing 6!](../../.gitbook/assets/screenshot-2020-01-03-at-12.28.27-pm.png)

Another way of calculating nth factorial is by multiplying 1 by 2, by 3, and so on till n.

```text
(define (factorial n)
    (fact-iter 1 1 n))
(define (fact-iter product counter max-count)
    (if (> counter max-count)
        product
        (fact-iter (* counter product)
            (+ counter 1)
            max-count)))
```

![ linear iterative process for computing 6!](../../.gitbook/assets/screenshot-2020-01-03-at-12.31.40-pm.png)

#### What's the difference?

Carrying out the linear recursive process requires that the interpreter keep track of the operations to be performed later on. The length of the chain of deferred multiplications, and hence the amount of information needed to keep track of it, grows linearly with n \(is proportional to n\). \(can take up more space in compilers without [tail recursion elimination](https://stackoverflow.com/questions/1240539/what-is-tail-recursion-elimination)\)

In general, an iterative process has a fixed number of state variables, with rules for updating those state variables as the process moves from state to state and an \(optional\) end test that specifies conditions under which the process should terminate. In computing n!, the number of steps required grows linearly with n. Such a process is called a linear iterative process.



